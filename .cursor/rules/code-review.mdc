---
description: "KapsamlÄ± code review kurallarÄ± â€” her commit/PR Ã¶ncesi ZORUNLU kontrol"
globs:
  - "src/**/*.cs"
alwaysApply: true
---

# Code Review KurallarÄ± (ZORUNLU)

Bu kontrol listesi her kod deÄŸiÅŸikliÄŸinde (commit veya PR Ã¶ncesi) uygulanÄ±r. AI, `code-review` komutu Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda veya commit hazÄ±rlarken bu kontrolleri otomatik yapar.

## KAPSAM KURALI (KRÄ°TÄ°K)

**Bir dosyada herhangi bir iÅŸlem yapÄ±ldÄ±ÄŸÄ±nda (dÃ¼zenleme, yeni metod, bug fix, refactoring), o dosyanÄ±n TAMAMI review edilir â€” sadece deÄŸiÅŸen satÄ±rlar deÄŸil.**

- Dosya aÃ§Ä±ldÄ±ÄŸÄ±nda veya dÃ¼zenlendiÄŸinde, dosyadaki TÃœM public metodlar kontrol edilir
- Sadece git diff'teki satÄ±rlara bakÄ±lmaz; dosyanÄ±n bÃ¼tÃ¼nÃ¼ taranÄ±r
- Proje kural ve mimarisine uymayan HER sorun tespit edilir ve dÃ¼zeltilir
- Mevcut (pre-existing) sorunlar da bulunur ve dÃ¼zeltilir â€” "ben deÄŸiÅŸtirmedim" mazeret deÄŸildir
- Eksik authorization, eksik logging, naming ihlali, boÅŸ catch, mimari ihlal vb. dosyanÄ±n neresinde olursa olsun raporlanÄ±r ve dÃ¼zeltilir

**Neden?** Bir dosyaya dokunduÄŸumuzda o dosyanÄ±n kalitesinden sorumluyuz. "Boy Scout Rule" â€” dosyayÄ± bulduÄŸundan daha temiz bÄ±rak.

### TODO YorumlarÄ± (ASLA ES GECME)

Dosyada `// TODO:`, `// FIXME:`, `// HACK:`, `// XXX:` gibi yorumlar varsa:
1. TÃ¼mÃ¼nÃ¼ tespit et ve listele
2. Her birini kullanÄ±cÄ±ya gÃ¶ster ve "Bu TODO'yu tamamlamamÄ± ister misin?" diye sor
3. KullanÄ±cÄ± onaylarsa â†’ TODO'yu tamamla ve yorumu kaldÄ±r
4. KullanÄ±cÄ± istemezse â†’ TODO'yu olduÄŸu gibi bÄ±rak ama raporda belirt
5. **HiÃ§bir zaman sessizce geÃ§me** â€” TODO'lar gÃ¶rÃ¼nmez borÃ§tur

---

## 1) GÃ¼venlik

| # | Kontrol | Seviye | AÃ§Ä±klama |
|---|---------|--------|----------|
| S1 | `[Authorize]` var mÄ±? | KRÄ°TÄ°K | Her public AppService metodu method-level `[Authorize]` taÅŸÄ±malÄ± |
| S2 | Class-level policy yok mu? | KRÄ°TÄ°K | `[Authorize(FitliyoPermissions....)]` class-level YASAK; sadece policysiz `[Authorize]` olabilir |
| S3 | Self-access kontrolÃ¼ var mÄ±? | KRÄ°TÄ°K | KiÅŸisel veri dÃ¶nen metodlarda `[AllowSelfAccess]` olmalÄ± |
| S4 | SQL injection riski var mÄ±? | KRÄ°TÄ°K | String interpolation/concat ile SQL Ã¼retilmemeli; LINQ veya parametreli sorgu kullan |
| S5 | Hassas veri loglanÄ±yor mu? | KRÄ°TÄ°K | Åifre, token, TC kimlik, IBAN log'a yazÄ±lmamalÄ± |
| S6 | Hassas veri hardcoded mÄ±? | KRÄ°TÄ°K | Connection string, API key, ÅŸifre kod iÃ§inde sabitlenmemeli |
| S7 | Input validation var mÄ±? | YÃœKSEK | DTO'larda `[Required]`, `[StringLength]`, `[Range]` vb. |
| S8 | `[AllowAnonymous]` gerekli mi? | YÃœKSEK | BilinÃ§li kullanÄ±lmalÄ±, gereksiz yere public endpoint aÃ§Ä±lmamalÄ± |

### Kontrol nasÄ±l yapÄ±lÄ±r:
```
â†’ DeÄŸiÅŸen .cs dosyalarÄ±nda [Authorize] attribute ara
â†’ Class-level policy varsa UYAR
â†’ DTO dosyalarÄ±nda validation attribute kontrolÃ¼
â†’ Log Ã§aÄŸrÄ±larÄ±nda hassas alan adÄ± arama (password, token, tcKimlik, iban, secret)
â†’ String concat ile SQL pattern arama ($"SELECT, $"UPDATE, $"DELETE, string.Format + SQL)
```

---

## 2) Performans

| # | Kontrol | Seviye | AÃ§Ä±klama |
|---|---------|--------|----------|
| P1 | N+1 query var mÄ±? | KRÄ°TÄ°K | DÃ¶ngÃ¼ iÃ§inde repository/DbContext Ã§aÄŸrÄ±sÄ± â†’ `Include`, tek sorgu veya toplu batch yap |
| P2 | Paging var mÄ±? | YÃœKSEK | Liste dÃ¶nen metodlarda `PagedResultRequestDto` kullanÄ±lmalÄ± |
| P3 | Cache-first uygulandÄ± mÄ±? | ORTA | Okuma operasyonlarÄ±nda Ã¶nce cache kontrol |
| P4 | Cache invalidation var mÄ±? | YÃœKSEK | Create/Update/Delete sonrasÄ± ilgili cache temizlenmeli |
| P5 | `Task.Result` / `Task.Wait()` var mÄ±? | KRÄ°TÄ°K | Deadlock riski; `await` kullan |
| P6 | Gereksiz eager load var mÄ±? | ORTA | KullanÄ±lmayan navigation property'ler Include edilmemeli |
| P7 | BÃ¼yÃ¼k veri memory'de mi? | ORTA | `ToListAsync()` yerine streaming/paging dÃ¼ÅŸÃ¼n |
| P8 | `CancellationToken` var mÄ±? | ORTA | Async metodlarda destek olmalÄ± |
| P9 | DÃ¶ngÃ¼ iÃ§inde dÄ±ÅŸ servis Ã§aÄŸrÄ±sÄ± var mÄ±? | KRÄ°TÄ°K | DÃ¶ngÃ¼/for/foreach iÃ§inde MinIO, HTTP, Redis, SMTP, SignalR gibi dÄ±ÅŸ servis Ã§aÄŸrÄ±sÄ± YASAK â†’ toplu batch metodu yaz/kullan |
| P10 | Toplu batch imkÃ¢nÄ± var mÄ±? | YÃœKSEK | N adet sÄ±ralÄ± await yerine toplu metot (batch API) varsa onu kullan; yoksa oluÅŸtur |
| P11 | `Task.WhenAll` gÃ¼venli mi? | YÃœKSEK | `Task.WhenAll` sadece batch metot **iÃ§inde** ve kontrollÃ¼ kullanÄ±lÄ±r â€” iÅŸ mantÄ±ÄŸÄ±nda doÄŸrudan kullanÄ±lmaz (aÅŸaÄŸÄ±daki kurala bak) |

### Kontrol nasÄ±l yapÄ±lÄ±r:
```
â†’ foreach/for iÃ§inde await Ã§aÄŸrÄ±sÄ± ara (repository, dÄ±ÅŸ servis, HTTP client, file storage, cache, SMTP hepsi dahil)
â†’ GetList metodlarÄ±nda PagedResultRequestDto kullanÄ±mÄ± kontrol
â†’ .Result, .Wait(), .GetAwaiter().GetResult() ara
â†’ Async metod imzalarÄ±nda CancellationToken parametresi kontrol
â†’ Liste dÃ¶nen metodlarda sonuÃ§ Ã¼zerinde sÄ±ralÄ± dÄ±ÅŸ servis Ã§aÄŸrÄ±sÄ± (URL Ã¼retme, dosya iÅŸlemi, bildirim vb.) ara
```

### ğŸ†• P9 â€” DÃ¶ngÃ¼ Ä°Ã§inde DÄ±ÅŸ Servis Ã‡aÄŸrÄ±sÄ± Anti-Pattern (KRÄ°TÄ°K)

**Kapsam:** Bu kural sadece veritabanÄ± sorgularÄ± ile sÄ±nÄ±rlÄ± DEÄÄ°LDÄ°R. AÅŸaÄŸÄ±daki TÃœM dÄ±ÅŸ servis Ã§aÄŸrÄ±larÄ±nÄ± kapsar:

| Kategori | Ã–rnek Servisler |
|----------|----------------|
| Dosya Depolama | MinIO (`GetPresignedUrlAsync`, `UploadAsync`, `ExistsAsync`) |
| HTTP Ä°stemci | `HttpClient`, `IRestClient`, harici API Ã§aÄŸrÄ±larÄ± |
| Cache | Redis (`GetAsync`, `SetAsync`, `RemoveAsync`) |
| Bildirim | SMTP, SMS, Push notification, SignalR (toplu gÃ¶nderim) |
| VeritabanÄ± | Repository (`GetAsync`, `FindAsync`, `GetListAsync`) |
| Blob/CDN | Azure Blob, S3, CDN URL Ã¼retimi |

**Anti-pattern (YASAK):**
```csharp
// âŒ N adet sÄ±ralÄ± dÄ±ÅŸ servis Ã§aÄŸrÄ±sÄ± â€” 500 kiÅŸi = 500 istek = 5-15 saniye bekleme
for (var i = 0; i < dtos.Count; i++)
    await _fileStorageService.GetPresignedUrlAsync(bucket, dtos[i].Path);
```

**DoÄŸru pattern (ZORUNLU):**
```csharp
// âœ… Toplu batch Ã§aÄŸrÄ±sÄ± â€” Ã§aÄŸÄ±ran taraf temiz kalÄ±r
var urlMap = await _fileStorageService.GetPresignedUrlsAsync(bucket, paths);
foreach (var dto in dtos)
    if (urlMap.TryGetValue(dto.Path, out var url))
        dto.Url = url;
```

**DÃ¼zeltme stratejisi (Ã¶ncelik sÄ±rasÄ±yla):**
1. Ä°lgili servis interface'inde toplu batch metodu var mÄ± kontrol et
2. Varsa â†’ batch metodunu kullan (Ã§aÄŸÄ±ran tarafta `Task.WhenAll` KULLANMA)
3. Yoksa â†’ servis interface'ine batch metodu oluÅŸtur (`GetPresignedUrlsAsync`, `GetByIdsAsync`, `SendBatchAsync` vb.)
4. Batch metot **iÃ§inde** paralelleme gerekiyorsa â†’ orada `Task.WhenAll` + hata yÃ¶netimi + loglama yap
5. **Bu kural mevcut (pre-existing) kodda da geÃ§erlidir** â€” dosyaya dokunulduÄŸunda dÃ¼zeltilir

### ğŸ†• P11 â€” `Task.WhenAll` KullanÄ±m KurallarÄ± (DÄ°KKAT)

`Task.WhenAll` **gÃ¼Ã§lÃ¼ ama tehlikeli** bir araÃ§tÄ±r. YanlÄ±ÅŸ kullanÄ±mÄ±:
- Connection pool tÃ¼kenmesi (DB, HTTP, MinIO)
- Rate limiting / throttling hatalarÄ±
- Partial failure â€” 499 baÅŸarÄ±lÄ±, 1 hata â†’ tÃ¼m `AggregateException` fÄ±rlar
- Kaynak tÃ¼kenmesi (thread/socket exhaustion)

**KURAL: `Task.WhenAll` doÄŸrudan iÅŸ mantÄ±ÄŸÄ±nda (AppService/Controller) KULLANILMAZ.**

`Task.WhenAll` yalnÄ±zca ÅŸu koÅŸullarda kullanÄ±labilir:
1. **Batch servis metodu iÃ§inde** (Ã¶r. `GetPresignedUrlsAsync` implementasyonu) â€” dÄ±ÅŸarÄ±ya temiz bir API sunulur
2. **Try-catch ile sarÄ±lÄ±** â€” her bir task'Ä±n hatasÄ± baÄŸÄ±msÄ±z yakalanÄ±r
3. **Loglama** â€” hatalÄ± Ã¶ÄŸeler loglanÄ±r, diÄŸerleri etkilenmez
4. **SonuÃ§ sÃ¶zlÃ¼ÄŸÃ¼** ile dÃ¶ner â€” baÅŸarÄ±lÄ±lar dahil, baÅŸarÄ±sÄ±zlar hariÃ§ (veya ayrÄ± rapor)

**âŒ YASAK â€” AppService'te doÄŸrudan Task.WhenAll:**
```csharp
// âŒ Tehlikeli: 500 paralel MinIO isteÄŸi, hata yÃ¶netimi yok, connection pool tÃ¼kenir
var tasks = dtos.Select(d => _fileStorageService.GetPresignedUrlAsync(bucket, d.Path));
var results = await Task.WhenAll(tasks);
```

**âœ… DOÄRU â€” Batch metot iÃ§inde kontrollÃ¼ Task.WhenAll:**
```csharp
// Batch metot (FileStorageService iÃ§inde)
public async Task<Dictionary<string, string>> GetPresignedUrlsAsync(
    string bucket, IEnumerable<string> objectNames, TimeSpan? expiry = null)
{
    var result = new Dictionary<string, string>();
    var tasks = objectNames.Select(async name =>
    {
        try
        {
            var url = await _provider.GetPresignedUrlAsync(bucket, name, expiry);
            return (name, url, success: true);
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Presigned URL hatasÄ±: {ObjectName}", name);
            return (name, url: (string?)null, success: false);
        }
    });
    var results = await Task.WhenAll(tasks);
    foreach (var r in results)
        if (r.success) result[r.name] = r.url!;
    return result;
}

// AppService'te (temiz Ã§aÄŸrÄ±):
var urlMap = await _fileStorageService.GetPresignedUrlsAsync(bucket, paths);
```

**Ã–zet:** Paralellik karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± **servis katmanÄ±nda** kapsÃ¼lle, **iÅŸ mantÄ±ÄŸÄ±nÄ±** temiz tut.

---

## 3) ABP / Katman KurallarÄ±

| # | Kontrol | Seviye | AÃ§Ä±klama |
|---|---------|--------|----------|
| A1 | Ä°ÅŸ mantÄ±ÄŸÄ± doÄŸru katmanda mÄ±? | YÃœKSEK | Domain logic â†’ Domain servis; orchestration â†’ AppService |
| A2 | DTO doÄŸru katmanda mÄ±? | YÃœKSEK | DTO'lar `Application.Contracts` iÃ§inde olmalÄ± |
| A3 | Application'dan DbContext eriÅŸimi var mÄ±? | KRÄ°TÄ°K | DoÄŸrudan DbContext YASAK; Repository kullan |
| A4 | Constructor policy atamalarÄ± var mÄ±? | ORTA | CRUD servislerinde `GetPolicyName`, `CreatePolicyName` vb. |
| A5 | `IMultiTenant` uygulanmÄ±ÅŸ mÄ±? | YÃœKSEK | Multi-tenant entity'lerde `TenantId` olmalÄ± |
| A6 | `IMultiSubTenant` uygulanmÄ±ÅŸ mÄ±? | YÃœKSEK | SubTenant filtreleme gereken entity'lerde |
| A7 | `IHasUserId` uygulanmÄ±ÅŸ mÄ±? | YÃœKSEK | KullanÄ±cÄ±ya ait entity'lerde `UserId` olmalÄ± |
| A8 | Protected constructor var mÄ±? | ORTA | Entity'lerde EF Core iÃ§in `protected` boÅŸ constructor |

### Kontrol nasÄ±l yapÄ±lÄ±r:
```
â†’ Entity dosyalarÄ±nda interface kontrolÃ¼ (IMultiTenant, IMultiSubTenant, IHasUserId)
â†’ Application katmanÄ±ndaki dosyalarda DbContext/FitliyoDbContext import arama
â†’ DTO dosyalarÄ±nÄ±n Application.Contracts altÄ±nda olduÄŸunu doÄŸrula
```

---

## 4) Hata YÃ¶netimi

| # | Kontrol | Seviye | AÃ§Ä±klama |
|---|---------|--------|----------|
| E1 | Genel `catch (Exception)` var mÄ±? | YÃœKSEK | Spesifik exception yakala; genel catch YASAK |
| E2 | BoÅŸ catch bloÄŸu var mÄ±? | KRÄ°TÄ°K | Exception yutulmamalÄ±; en azÄ±ndan logla |
| E3 | `UserFriendlyException` doÄŸru mu? | ORTA | KullanÄ±cÄ±ya dÃ¶nen mesajlar TÃ¼rkÃ§e ve anlamlÄ± |
| E4 | `BusinessException` error code var mÄ±? | ORTA | `FitliyoDomainErrorCodes` sabiti kullanÄ±lmalÄ± |
| E5 | Null check / guard clause var mÄ±? | YÃœKSEK | Metod baÅŸÄ±nda parametre kontrolÃ¼ |
| E6 | Catch bloÄŸunda scope dÄ±ÅŸÄ± deÄŸiÅŸken mi? | KRÄ°TÄ°K | try iÃ§inde tanÄ±mlanan deÄŸiÅŸken catch'te eriÅŸilemez; metod parametresi veya try Ã¶ncesi deÄŸiÅŸken kullan |

### Kontrol nasÄ±l yapÄ±lÄ±r:
```
â†’ catch (Exception) veya catch (Exception ex) { } (boÅŸ body) ara
â†’ throw new UserFriendlyException Ã§aÄŸrÄ±larÄ±nda TÃ¼rkÃ§e mesaj kontrolÃ¼
â†’ throw new BusinessException Ã§aÄŸrÄ±larÄ±nda FitliyoDomainErrorCodes kullanÄ±mÄ±
```

---

## 5) Loglama

| # | Kontrol | Seviye | AÃ§Ä±klama |
|---|---------|--------|----------|
| L1 | Structured logging kullanÄ±lÄ±yor mu? | YÃœKSEK | `_logger.LogInformation("{UserId}", id)` â€” string interpolation YASAK |
| L2 | Hassas veri loglanÄ±yor mu? | KRÄ°TÄ°K | Åifre, token, TC kimlik loglanmamalÄ± |
| L3 | Ã–nemli iÅŸlemler loglanÄ±yor mu? | ORTA | Create/Update/Delete iÅŸlemleri loglanmalÄ± |
| L4 | Exception loglanÄ±yor mu? | YÃœKSEK | Catch bloklarÄ±nda `_logger.LogError(ex, ...)` olmalÄ± |

### Kontrol nasÄ±l yapÄ±lÄ±r:
```
â†’ _logger.Log* Ã§aÄŸrÄ±larÄ±nda $"..." (string interpolation) arama â†’ structured logging olmalÄ±
â†’ Log Ã§aÄŸrÄ±larÄ±nda password, token, secret, tcKimlik, iban alanlarÄ± arama
```

---

## 6) Kod Kalitesi

| # | Kontrol | Seviye | AÃ§Ä±klama |
|---|---------|--------|----------|
| K1 | Metot 50+ satÄ±r mÄ±? | ORTA | Refactor Ã¶ner; tek sorumluluk prensibi |
| K2 | Parametre sayÄ±sÄ± 5+ mÄ±? | ORTA | Parametre nesnesi (DTO/record) Ã¶ner |
| K3 | Magic string/number var mÄ±? | YÃœKSEK | Sabit (const/enum) olarak tanÄ±mla |
| K4 | KullanÄ±lmayan import var mÄ±? | DÃœÅÃœK | Temizle |
| K5 | Naming convention'a uygun mu? | ORTA | PascalCase, _camelCase, Async suffix |
| K6 | XML summary var mÄ±? | ORTA | Public entity ve kritik property'lerde TÃ¼rkÃ§e `<summary>` |
| K7 | `DateTime.UtcNow` kullanÄ±lmÄ±ÅŸ mÄ±? | YÃœKSEK | `DateTime.Now` kullan (proje TÃ¼rkiye lokali ile Ã§alÄ±ÅŸÄ±r) |
| K8 | `public` field var mÄ±? | YÃœKSEK | Property kullan |
| K9 | Dosyada birden fazla tip tanÄ±mÄ± var mÄ±? | YÃœKSEK | Her class, interface, enum, record kendi dosyasÄ±nda olmalÄ± â€” tek dosyada tek tip |

---

## 7) Multi-Tenancy & SubTenant

| # | Kontrol | Seviye | AÃ§Ä±klama |
|---|---------|--------|----------|
| M1 | Tenant context doÄŸru mu? | KRÄ°TÄ°K | Cross-tenant veri sÄ±zÄ±ntÄ±sÄ± riski |
| M2 | SubTenant filtreleme var mÄ±? | YÃœKSEK | `IMultiSubTenant` entity'lerde SubTenantId filtrelenmeli |
| M3 | Job'larda tenant context var mÄ±? | KRÄ°TÄ°K | Background job'larda `ClaimsIdentity` auth type ile oluÅŸturulmalÄ± |
| M4 | Context switch doÄŸru mu? | KRÄ°TÄ°K | `new ClaimsIdentity(claims, "ContextSwitch")` â€” auth type zorunlu |

---

## 8) DokÃ¼mantasyon Etkisi

| # | Kontrol | Seviye | AÃ§Ä±klama |
|---|---------|--------|----------|
| D1 | CHANGELOG gÃ¼ncellendi mi? | ZORUNLU | Her anlamlÄ± deÄŸiÅŸiklikte |
| D2 | Next.js frontend etkileniyor mu? | ZORUNLU | Evet â†’ `docs/frontend-changes/YYYY-MM-DD-N.md` oluÅŸtur (MVC deÄŸiÅŸiklikleri hariÃ§!) |
| D3 | Yetkilendirme matrisi gÃ¼ncel mi? | ZORUNLU | Permission deÄŸiÅŸtiyse AppService dokÃ¼manÄ± gÃ¼ncelle |
| D4 | Swagger gÃ¼ncellenmeli mi? | ZORUNLU | Endpoint/DTO deÄŸiÅŸtiyse snapshot Ã¼ret |

---

## 9) Katman BaÄŸÄ±mlÄ±lÄ±k KontrolÃ¼ (MÄ°MARÄ° KORUMA)

Proje mimarisinin bozulmamasÄ± iÃ§in katmanlar arasÄ± baÄŸÄ±mlÄ±lÄ±klar **kesinlikle** kontrol edilir.

### Ä°zin Verilen BaÄŸÄ±mlÄ±lÄ±k HaritasÄ±

```mermaid
graph TD
    DomainShared["Domain.Shared<br/>(enum, const, error code)"]
    Domain["Domain<br/>(entity, domain servis)"]
    Contracts["Application.Contracts<br/>(DTO, interface, permission)"]
    Application["Application<br/>(AppService, orchestration)"]
    EFCore["EntityFrameworkCore<br/>(mapping, repository)"]
    HttpApi["HttpApi<br/>(controller)"]
    Web["Web<br/>(host, Razor)"]
    RedisCache["RedisCache"]
    FileStorage["FileStorage"]
    Mailing["Mailing"]
    Publisher["Publisher"]
    HangfireCore["Hangfire.Core"]
    Hangfire["Hangfire"]
    WebClient["Web.Client"]
    Logging["Logging"]

    Domain --> DomainShared
    Contracts --> DomainShared
    Contracts --> Domain
    Application --> Contracts
    Application --> Domain
    EFCore --> Domain
    EFCore --> DomainShared
    HttpApi --> Contracts
    HttpApi --> Application
    RedisCache --> DomainShared
    RedisCache --> Contracts
    FileStorage --> DomainShared
    Publisher --> DomainShared
    Mailing --> DomainShared
    Mailing --> Contracts
    Logging --> DomainShared
    Logging --> Contracts
    WebClient --> RedisCache
    WebClient --> Logging
    HangfireCore --> EFCore
    HangfireCore --> Contracts
    Application --> WebClient
    Application --> FileStorage
    Application --> Mailing
    Application --> Publisher
    Hangfire --> Application
    Hangfire --> HangfireCore
    Hangfire --> EFCore
    HttpApi --> FileStorage
    Web --> Application
    Web --> HttpApi
    Web --> EFCore
    Web --> RedisCache
    Web --> Hangfire
```

### YASAK BaÄŸÄ±mlÄ±lÄ±klar (KRÄ°TÄ°K)

| Kaynak Katman | YASAK Hedef | Neden |
|---------------|-------------|-------|
| **Domain** | Application, EFCore, HttpApi, Web | Domain saf kalmalÄ±; altyapÄ±dan baÄŸÄ±msÄ±z |
| **Domain** | Contracts | Domain, Contracts'a baÄŸÄ±mlÄ± olmamalÄ± (tersi olmalÄ±) |
| **Domain.Shared** | HER PROJE | En alt katman; hiÃ§bir ÅŸeye baÄŸÄ±mlÄ± olmamalÄ± |
| **Contracts** | Application, EFCore, HttpApi | Contracts sadece tanÄ±m iÃ§erir; implementasyon bilmez |
| **Application** | EFCore, HttpApi, Web | Application, altyapÄ± detaylarÄ±nÄ± bilmemeli |
| **Application** | DbContext, IDbContextFactory | DoÄŸrudan EF Core eriÅŸimi YASAK; Repository kullan |
| **EFCore** | Application, HttpApi, Web | EFCore sadece Domain bilir |
| **HttpApi** | EFCore, Web | Controller sadece AppService Ã§aÄŸÄ±rÄ±r |

### Kontrol NasÄ±l YapÄ±lÄ±r

```
â†’ DeÄŸiÅŸen dosyanÄ±n hangi projede olduÄŸunu belirle
â†’ Dosyadaki using/import satÄ±rlarÄ±nÄ± kontrol et
â†’ Yasak baÄŸÄ±mlÄ±lÄ±k varsa KRÄ°TÄ°K hata olarak raporla
â†’ Ã–zellikle ÅŸu pattern'lere dikkat:
  - Domain katmanÄ±nda: using Fitliyo.Application.* veya using Fitliyo.EntityFrameworkCore.*
  - Application katmanÄ±nda: using Microsoft.EntityFrameworkCore.* veya using Fitliyo.EntityFrameworkCore.*
  - Contracts katmanÄ±nda: using Fitliyo.Application.* (implementasyon import'u)
```

### SÄ±k YapÄ±lan Ä°hlaller

| Ä°hlal | Ã–rnek | DoÄŸrusu |
|-------|-------|---------|
| Application'dan DbContext | `_dbContext.Users.Where(...)` | `_repository.GetListAsync(...)` |
| Domain'den Repository Ã§aÄŸrÄ±sÄ± | `_userRepo.GetAsync(id)` | Domain servisine repository inject et, Application'da Ã§aÄŸÄ±r |
| Contracts'ta iÅŸ mantÄ±ÄŸÄ± | `if (dto.Amount > 0) ...` validation logic | Validation â†’ DTO attribute; business â†’ Domain servis |
| HttpApi'de iÅŸ mantÄ±ÄŸÄ± | Controller'da if/else business logic | AppService'e taÅŸÄ± |

---

## 10) MantÄ±k HatasÄ± Tespiti

Kod deÄŸiÅŸikliklerinde iÅŸ mantÄ±ÄŸÄ± hatalarÄ± aktif olarak aranÄ±r ve doÄŸrusu Ã¶nerilir.

### Kontrol Edilenler

| # | Kontrol | AÃ§Ä±klama |
|---|---------|----------|
| M1 | **KoÅŸul tersliÄŸi** | `if (user != null)` olmasÄ± gereken yerde `if (user == null)` |
| M2 | **Tarih karÅŸÄ±laÅŸtÄ±rma** | `startDate > endDate` kontrolÃ¼nÃ¼n eksik veya ters olmasÄ± |
| M3 | **Null reference riski** | Nullable deÄŸer kontrol edilmeden kullanÄ±m |
| M4 | **Off-by-one** | DÃ¶ngÃ¼/sayfalama sÄ±nÄ±rlarÄ±nda Â±1 hatasÄ± |
| M5 | **YanlÄ±ÅŸ enum kullanÄ±mÄ±** | Enum karÅŸÄ±laÅŸtÄ±rmada yanlÄ±ÅŸ deÄŸer |
| M6 | **Eksik filter** | Multi-tenant/SubTenant filtresinin atlanmasÄ± |
| M7 | **Race condition** | Check-then-act pattern'inde yarÄ±ÅŸ durumu |
| M8 | **YanlÄ±ÅŸ sÄ±ralama** | Create'de Ã¶nce child sonra parent oluÅŸturma |
| M9 | **Cache tutarsÄ±zlÄ±ÄŸÄ±** | Veri gÃ¼ncellendi ama cache invalidate edilmedi |
| M10 | **Authorization bypass** | Self-access kontrolÃ¼nde userId doÄŸrulamasÄ± eksik |

### Kontrol NasÄ±l YapÄ±lÄ±r

```
â†’ if/else koÅŸullarÄ±nÄ± semantik olarak analiz et
â†’ Date karÅŸÄ±laÅŸtÄ±rmalarÄ±nda mantÄ±k kontrolÃ¼
â†’ Nullable eriÅŸimlerde ?. veya null check olup olmadÄ±ÄŸÄ±
â†’ CRUD operasyonlarÄ±nda iÅŸlem sÄ±rasÄ± (parent Ã¶nce, child sonra)
â†’ Cache okuma/yazma/silme tutarlÄ±lÄ±ÄŸÄ±
â†’ Authorization flow'da userId parametresinin doÄŸrulanmasÄ±
```

### Raporlama FormatÄ±

```markdown
### [MANTIK] SatÄ±r 120: Tarih karÅŸÄ±laÅŸtÄ±rma hatasÄ±
**Mevcut:** `if (input.EndDate > input.StartDate)` â†’ BitiÅŸ tarihi baÅŸlangÄ±Ã§tan bÃ¼yÃ¼kse hata fÄ±rlatÄ±yor
**Sorun:** KoÅŸul ters; bitiÅŸ tarihi baÅŸlangÄ±Ã§tan bÃ¼yÃ¼k olmasÄ± NORMAL
**Ã–neri:** `if (input.EndDate < input.StartDate) throw new BusinessException(...)`
```

---

## 11) Kod TekrarÄ± ve Mevcut Kod KontrolÃ¼ (YENÄ° KOD YAZMADAN Ã–NCE)

**Yeni kod yazmadan veya yeni bir metod/servis eklemeden Ã¶nce**, projede aynÄ± iÅŸi yapan mevcut kodun olup olmadÄ±ÄŸÄ± **zorunlu** kontrol edilir.

### Kontrol SÄ±rasÄ±

1. **AynÄ± isimde metod/servis var mÄ±?** â†’ Grep ile ara
2. **Benzer iÅŸ yapan metod var mÄ±?** â†’ Semantic search ile ara
3. **Ortak utility/helper var mÄ±?** â†’ `Extensions/`, `Helpers/`, `Shared/` klasÃ¶rlerini kontrol et
4. **Base class'ta var mÄ±?** â†’ `CrudAppService`, `ApplicationService` base metodlarÄ±nÄ± kontrol et
5. **Domain serviste var mÄ±?** â†’ Ä°ÅŸ mantÄ±ÄŸÄ± zaten domain'de mi?

### Aranacak Yerler

| Yeni Eklenecek | Kontrol Edilecek Yerler |
|----------------|----------------------|
| AppService metodu | AynÄ± entity'nin mevcut AppService'i, base class metodlarÄ± |
| Helper/Extension metodu | `src/**/Extensions/`, `src/**/Helpers/`, `Domain.Shared` |
| DTO | `Application.Contracts` altÄ±nda benzer DTO |
| Repository metodu | `IRepository<T>` base metodlarÄ±, mevcut custom repository |
| Validation logic | Mevcut DTO attribute'larÄ±, `FluentValidation` kurallarÄ± |
| Cache key/pattern | `RedisCache/` altÄ±ndaki mevcut cache servisleri |
| Error code | `FitliyoDomainErrorCodes` mevcut sabitler |
| Permission | `FitliyoPermissions` mevcut tanÄ±mlar |
| Enum | `Domain.Shared/Enums/` mevcut enum'lar |

### YaygÄ±n Tekrar Pattern'leri

| Tekrar | Ã‡Ã¶zÃ¼m |
|--------|-------|
| Her servisde aynÄ± null check | Guard clause helper veya base class'a taÅŸÄ± |
| Her servisde aynÄ± cache pattern | Generic cache servis (`ICacheService<T>`) |
| Her servisde aynÄ± SubTenant filtre | `IMultiSubTenant` + global query filter |
| Her servisde aynÄ± user lookup | `IUserLookupService` veya mevcut helper |
| Her DTO'da aynÄ± alanlar | Base DTO class (Ã¶r. `AuditedEntityDto`) |
| AynÄ± exception mesajÄ± farklÄ± yerlerde | `FitliyoDomainErrorCodes` sabiti |

### Raporlama FormatÄ±

```markdown
### [TEKRAR] GetTrainerByIdAsync â€” Mevcut kod zaten var
**Yeni eklenen:** `ReviewAppService.GetTrainerByIdAsync(Guid trainerProfileId)`
**Mevcut:** `TrainerProfileAppService.GetAsync(Guid id)` aynÄ± iÅŸi yapÄ±yor (satÄ±r 45)
**Ã–neri:** Mevcut `TrainerProfileAppService.GetAsync` kullanÄ±lmalÄ± veya `ITrainerProfileRepository` inject edilmeli
```

```markdown
### [TEKRAR] Cache key pattern tekrarÄ±
**Yeni eklenen:** `$"TrainerPackages:{trainerProfileId}"` (satÄ±r 80)
**Mevcut:** `ServicePackageCacheService` zaten bu cache key'i yÃ¶netiyor
**Ã–neri:** `IServicePackageCacheService` inject edip mevcut metodu kullan
```

### AI TalimatÄ±

Yeni kod yazarken ÅŸu adÄ±mlar **otomatik** uygulanÄ±r:
1. Eklenecek metod/class ismini projede Grep ile ara
2. Benzer iÅŸlev yapan kodlarÄ± SemanticSearch ile ara
3. Base class metodlarÄ±nÄ± kontrol et (CrudAppService'in GetAsync, GetListAsync, CreateAsync vb.)
4. Mevcut helper/extension'larÄ± kontrol et
5. Tekrar tespit edilirse â†’ mevcut kodu kullanmayÄ± Ã¶ner, yeni kod yazmaktan kaÃ§Ä±n

---

## Review Ã‡Ä±ktÄ± FormatÄ±

### Temel Kural: Her Bulgu = Kesin Ã‡Ã¶zÃ¼m + Opsiyonel Alternatifler

Her review bulgusu ÅŸu yapÄ±da raporlanÄ±r:

1. **Sorun tespiti** (ne, nerede, neden)
2. **Kesin Ã§Ã¶zÃ¼m** (uygulanmasÄ± gereken dÃ¼zeltme â€” kod ile)
3. **Alternatif Ã§Ã¶zÃ¼mler** (varsa, artÄ±/eksileriyle birlikte)

### Bulgu FormatÄ±

```markdown
#### [KATEGORÄ°-NUMARA] SatÄ±r XX: KÄ±sa baÅŸlÄ±k
**Seviye:** KRÄ°TÄ°K / YÃœKSEK / ORTA
**Sorun:** Ne yanlÄ±ÅŸ ve neden sorun
**Mevcut kod:**
\```csharp
// satÄ±r XX
sorunlu kod buraya
\```

**Kesin Ã‡Ã¶zÃ¼m:**
\```csharp
// dÃ¼zeltilmiÅŸ kod
doÄŸru kod buraya
\```

**Alternatif Ã‡Ã¶zÃ¼mler:** (varsa)
| # | Ã‡Ã¶zÃ¼m | ArtÄ±larÄ± | Eksileri |
|---|-------|----------|---------|
| A | KÄ±sa aÃ§Ä±klama + kod snippet | Avantajlar | Dezavantajlar |
| B | KÄ±sa aÃ§Ä±klama + kod snippet | Avantajlar | Dezavantajlar |
```

### Tam Rapor Ã–rneÄŸi

```markdown
## Code Review Raporu

**Dosya:** `src/Fitliyo.Application/Xxx/XxxAppService.cs`
**Tarih:** YYYY-MM-DD
**Durum:** âŒ Kritik sorunlar var

---

#### [S1] SatÄ±r 45: GetListAsync metodunda [Authorize] eksik
**Seviye:** KRÄ°TÄ°K
**Sorun:** Public AppService metodu authorization attribute'siz; herkes eriÅŸebilir.
**Mevcut kod:**
\```csharp
public override async Task<PagedResultDto<XxxDto>> GetListAsync(GetXxxListDto input)
\```

**Kesin Ã‡Ã¶zÃ¼m:**
\```csharp
[Authorize(FitliyoPermissions.Xxx.View)]
[AllowSelfAccess("UserId", Module = SelfAccessModules.Xxx)]
public override async Task<PagedResultDto<XxxDto>> GetListAsync(GetXxxListDto input)
\```

---

#### [BAG] SatÄ±r 3: Application katmanÄ±ndan EF Core import edilmiÅŸ
**Seviye:** KRÄ°TÄ°K
**Sorun:** Application katmanÄ± altyapÄ± detaylarÄ±nÄ± bilmemeli; mimari katman ihlali.
**Mevcut kod:**
\```csharp
using Microsoft.EntityFrameworkCore;
// ...
var users = await _dbContext.Users.Where(x => x.IsActive).ToListAsync();
\```

**Kesin Ã‡Ã¶zÃ¼m:**
\```csharp
var users = await _userRepository.GetListAsync(x => x.IsActive);
\```

**Alternatif Ã‡Ã¶zÃ¼mler:**
| # | Ã‡Ã¶zÃ¼m | ArtÄ±larÄ± | Eksileri |
|---|-------|----------|---------|
| A | Custom repository metodu ekle (`IUserRepository.GetActiveUsersAsync`) | Semantik, test edilebilir, tekrar kullanÄ±labilir | Yeni interface + implementasyon |
| B | Specification pattern (`new ActiveUsersSpec()`) | ABP uyumlu, composable | KÃ¼Ã§Ã¼k sorgular iÃ§in over-engineering |

---

#### [P1] SatÄ±r 80: DÃ¶ngÃ¼ iÃ§inde repository Ã§aÄŸrÄ±sÄ± (N+1)
**Seviye:** YÃœKSEK
**Sorun:** Her iterasyonda ayrÄ± DB sorgusu â†’ N+1 problem; 100 kayÄ±tta 101 sorgu.
**Mevcut kod:**
\```csharp
foreach (var item in items)
{
    var user = await _userRepository.GetAsync(item.UserId);
    item.UserName = user.Name;
}
\```

**Kesin Ã‡Ã¶zÃ¼m:**
\```csharp
var userIds = items.Select(x => x.UserId).Distinct().ToList();
var users = await _userRepository.GetListAsync(x => userIds.Contains(x.Id));
var userMap = users.ToDictionary(x => x.Id);
foreach (var item in items)
{
    if (userMap.TryGetValue(item.UserId, out var user))
        item.UserName = user.Name;
}
\```

**Alternatif Ã‡Ã¶zÃ¼mler:**
| # | Ã‡Ã¶zÃ¼m | ArtÄ±larÄ± | Eksileri |
|---|-------|----------|---------|
| A | Include ile eager loading (EF Core navigation) | Tek sorgu, basit | Sadece EFCore'da Ã§alÄ±ÅŸÄ±r, gereksiz veri yÃ¼klenebilir |
| B | Projection ile DTO direkt Ã§ek | En performanslÄ±, sadece gerekli alanlar | Mapping karmaÅŸÄ±klÄ±ÄŸÄ± |

---

#### [MANTIK] SatÄ±r 85: Tarih karÅŸÄ±laÅŸtÄ±rma hatasÄ±
**Seviye:** YÃœKSEK
**Sorun:** BitiÅŸ tarihi baÅŸlangÄ±Ã§tan bÃ¼yÃ¼kse hata fÄ±rlatÄ±lÄ±yor â€” koÅŸul ters.
**Mevcut kod:**
\```csharp
if (input.EndDate > input.StartDate)
    throw new BusinessException(FitliyoDomainErrorCodes.InvalidDateRange);
\```

**Kesin Ã‡Ã¶zÃ¼m:**
\```csharp
if (input.EndDate < input.StartDate)
    throw new BusinessException(FitliyoDomainErrorCodes.InvalidDateRange);
\```

---

#### [TEKRAR] GetTrainerDisplayNameAsync â€” mevcut kod zaten var
**Seviye:** ORTA
**Sorun:** AynÄ± iÅŸi yapan `TrainerProfileAppService.GetAsync` zaten profil bilgilerini dÃ¶ndÃ¼rÃ¼yor.
**Mevcut kod:**
\```csharp
private async Task<string> GetTrainerDisplayNameAsync(Guid trainerProfileId)
{
    var profile = await _trainerProfileRepository.GetAsync(trainerProfileId);
    var user = await _userRepository.GetAsync(profile.UserId);
    return $"{user.Name} {user.Surname}";
}
\```

**Kesin Ã‡Ã¶zÃ¼m:**
\```csharp
var profile = await _trainerProfileAppService.GetAsync(trainerProfileId);
var displayName = profile.TrainerFullName;
\```

**Alternatif Ã‡Ã¶zÃ¼mler:**
| # | Ã‡Ã¶zÃ¼m | ArtÄ±larÄ± | Eksileri |
|---|-------|----------|---------|
| A | Cache'li TrainerProfile kullan | Tekrar yok, performanslÄ± | Dependency eklenmeli |
| B | Denormalize alan (TrainerProfile.DisplayName) | Sorgu gerekmiyor | Senkronizasyon gerekir |

---

### Ã–zet
| Kategori | Kritik | UyarÄ± | Bilgi |
|----------|--------|-------|-------|
| GÃ¼venlik | 1 | 0 | 0 |
| Performans | 0 | 1 | 0 |
| Katman BaÄŸÄ±mlÄ±lÄ±k | 1 | 0 | 0 |
| MantÄ±k HatasÄ± | 1 | 0 | 0 |
| Kod TekrarÄ± | 0 | 1 | 0 |
| DokÃ¼mantasyon | 0 | 0 | 2 |
| **Toplam** | **3** | **2** | **2** |
```

### Ã‡Ã¶zÃ¼m Sunma KurallarÄ± (AI iÃ§in ZORUNLU)

1. **Her bulgu mutlaka "Kesin Ã‡Ã¶zÃ¼m" iÃ§ermeli** â€” sadece sorun tespit etmek yetmez
2. Kesin Ã§Ã¶zÃ¼m **uygulanabilir kod** olmalÄ± â€” soyut tavsiye deÄŸil, kopyala-yapÄ±ÅŸtÄ±r yapÄ±labilir
3. Kesin Ã§Ã¶zÃ¼m projenin **mevcut pattern ve convention'larÄ±na** uygun olmalÄ±
4. Alternatif Ã§Ã¶zÃ¼mler varsa **artÄ±/eksi tablosuyla** sunulmalÄ±
5. Alternatifler arasÄ±nda **hangi durumda hangisinin tercih edilmesi gerektiÄŸi** belirtilmeli
6. Ã‡Ã¶zÃ¼m Ã¶nerisinde **mevcut projeden benzer doÄŸru kullanÄ±m Ã¶rneÄŸi** varsa referans gÃ¶sterilmeli

---

## Otomatik Tetikleme

Bu review kurallarÄ± ÅŸu durumlarda uygulanÄ±r:
1. **Dosya dÃ¼zenlendiÄŸinde** â€” dÃ¼zenlenen dosyanÄ±n TAMAMI review edilir (sadece diff deÄŸil)
2. **`code-review` komutu** Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda â€” staged veya belirtilen dosyalarÄ±n tamamÄ± taranÄ±r
3. **Commit oluÅŸturulurken** â€” AI otomatik kontrol yapar
4. **`full-check` komutu** Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda â€” tÃ¼m kontroller sÄ±rayla

**DÃ¼zenleme sÄ±rasÄ±nda:** Bir dosyada tek satÄ±r bile deÄŸiÅŸtirildiyse, o dosyadaki TÃœM sorunlar (pre-existing dahil) tespit edilir ve dÃ¼zeltilir. Sadece deÄŸiÅŸen satÄ±rlara bakÄ±lmaz.

Referanslar:
- [`.cursor/rules/code-quality.mdc`](code-quality.mdc) â€” DetaylÄ± kod kalitesi standartlarÄ±
- [`.cursor/rules/security-performance.mdc`](security-performance.mdc) â€” GÃ¼venlik ve performans kurallarÄ±
- [`.cursor/rules/auto-generation.mdc`](auto-generation.mdc) â€” Entity/AppService kurallarÄ±
- [`docs/standards/ERROR_HANDLING.md`](../../docs/standards/ERROR_HANDLING.md) â€” Hata yÃ¶netimi standardÄ±
- [`docs/AUTHORIZATION-SYSTEM.md`](../../docs/AUTHORIZATION-SYSTEM.md) â€” Yetkilendirme sistemi
